<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>274</fr:anchor>
    <fr:addr type="user">pages</fr:addr>
    <fr:route>pages.xml</fr:route>
    <fr:title text="All Pages">All Pages</fr:title>
    <fr:authors />
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>
      <fr:ul>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="admissible-rule.xml" addr="admissible-rule" title="Admissible Rules">Admissible Rules</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="algebra.xml" addr="algebra" title="Algebra">Algebra</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="categories-with-families.xml" addr="categories-with-families" title="Categories with Families">Categories with Families</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="elaboration-formal.xml" addr="elaboration-formal" title="Elaboration, Formally">Elaboration, Formally</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="elaboration-intuition.xml" addr="elaboration-intuition" title="Elaboration, Intuitively">Elaboration, Intuitively</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">Elaboration</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">Theories</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">Judgements</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="judgements-disc.xml" addr="judgements-disc" title="Judgements">Judgements</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">Kernel Languages</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="macro-elab-definition.xml" addr="macro-elab-definition" title="A Macro-Based Explanation of Elaboration">A Macro-Based Explanation of Elaboration</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="macro-expansion.xml" addr="macro-expansion" title="Macro Expansion">Macro Expansion</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="mltt-disc.xml" addr="mltt-disc" title="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="mltt-pi-rules.xml" addr="mltt-pi-rules" title="Rules for Pi Types in MLTT">Rules for Pi Types in MLTT</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="mltt-pres-trad.xml" addr="mltt-pres-trad" title="Traditional Presentation of MLTT">Traditional Presentation of MLTT</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="mltt.xml" addr="mltt" title="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="programming-language-explosion.xml" addr="programming-language-explosion" title="Continued Explosion of Programming Languages">Continued Explosion of Programming Languages</fr:link></fr:li>
        <fr:li><fr:strong>Problem</fr:strong>. <fr:link type="local" href="proof-assistant-explosion.xml" addr="proof-assistant-explosion" title="Constructing Proof Assistants">Constructing Proof Assistants</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="readable-theorems.xml" addr="readable-theorems" title="Should Kernel Theorems be Readable?">Should Kernel Theorems be Readable?</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="rel-judgements-fol.xml" addr="rel-judgements-fol" title="Judgements and FOL">Judgements and FOL</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="rel-judgements-natural-deduction.xml" addr="rel-judgements-natural-deduction" title="Judgements and Natural Deduction">Judgements and Natural Deduction</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="signature.xml" addr="signature" title="Signatures">Signatures</fr:link></fr:li>
        <fr:li><fr:strong>Lemma</fr:strong>. <fr:link type="local" href="srs-eager-is-eager.xml" addr="srs-eager-is-eager" title="Eager Evaluation is Eager">Eager Evaluation is Eager</fr:link></fr:li>
        <fr:li><fr:strong>Proof</fr:strong>. <fr:link type="local" href="srs-eager-prop-proof.xml" addr="srs-eager-prop-proof" title="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:link></fr:li>
        <fr:li><fr:strong>Theorem</fr:strong>. <fr:link type="local" href="srs-eager-prop.xml" addr="srs-eager-prop" title="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:link></fr:li>
        <fr:li><fr:strong>Theorem</fr:strong>. <fr:link type="local" href="srs-eager-twice-noop.xml" addr="srs-eager-twice-noop" title="Normalizing Normalize Does Nothing">Normalizing Normalize Does Nothing</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">Eager Evaluation in String Rewrite Systems</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">String Rewrite System</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="tactics.xml" addr="tactics" title="Tactics">Tactics</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="tt-as-algebra.xml" addr="tt-as-algebra" title="Type Theories as Algebraic Theories">Type Theories as Algebraic Theories</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="tt-as-cwf.xml" addr="tt-as-cwf" title="Type Theories as Categories with Families">Type Theories as Categories with Families</fr:link></fr:li>
        <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="type-theory.xml" addr="type-theory" title="Type Theory">Type Theory</fr:link></fr:li>
        <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="vernacular.xml" addr="vernacular" title="Vernacular Languages">Vernacular Languages</fr:link></fr:li>
        <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="why-formal-elab.xml" addr="why-formal-elab" title="Why Formalize Elaboration?">Why Formalize Elaboration?</fr:link></fr:li>
      </fr:ul>
    </fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>275</fr:anchor>
            <fr:addr type="user">index</fr:addr>
            <fr:route>index.xml</fr:route>
            <fr:title text="Eashan Hatti">Eashan Hatti</fr:title>
            <fr:taxon>Person</fr:taxon>
            <fr:authors />
            <fr:meta name="external">https://ehatti.github.io/</fr:meta>
            <fr:meta name="institution">Yale University</fr:meta>
            <fr:meta name="position">Undergraduate CS Student</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>I'm a CS undergrad at Yale University, primarily interested in automated formal methods and the construction of proof assistants. These are my public notes, if you have any comments -- disagreement, agreement, discussion, or otherwise -- feel free to message me at <fr:code>eashan.hatti@yale.edu</fr:code>!</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>276</fr:anchor>
                <fr:addr type="user">pages</fr:addr>
                <fr:route>pages.xml</fr:route>
                <fr:title text="All Pages">All Pages</fr:title>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>
                  <fr:ul>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="admissible-rule.xml" addr="admissible-rule" title="Admissible Rules">Admissible Rules</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="algebra.xml" addr="algebra" title="Algebra">Algebra</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="categories-with-families.xml" addr="categories-with-families" title="Categories with Families">Categories with Families</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="elaboration-formal.xml" addr="elaboration-formal" title="Elaboration, Formally">Elaboration, Formally</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="elaboration-intuition.xml" addr="elaboration-intuition" title="Elaboration, Intuitively">Elaboration, Intuitively</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">Elaboration</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">Theories</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">Judgements</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="judgements-disc.xml" addr="judgements-disc" title="Judgements">Judgements</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">Kernel Languages</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="macro-elab-definition.xml" addr="macro-elab-definition" title="A Macro-Based Explanation of Elaboration">A Macro-Based Explanation of Elaboration</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="macro-expansion.xml" addr="macro-expansion" title="Macro Expansion">Macro Expansion</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="mltt-disc.xml" addr="mltt-disc" title="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="mltt-pi-rules.xml" addr="mltt-pi-rules" title="Rules for Pi Types in MLTT">Rules for Pi Types in MLTT</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="mltt-pres-trad.xml" addr="mltt-pres-trad" title="Traditional Presentation of MLTT">Traditional Presentation of MLTT</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="mltt.xml" addr="mltt" title="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="programming-language-explosion.xml" addr="programming-language-explosion" title="Continued Explosion of Programming Languages">Continued Explosion of Programming Languages</fr:link></fr:li>
                    <fr:li><fr:strong>Problem</fr:strong>. <fr:link type="local" href="proof-assistant-explosion.xml" addr="proof-assistant-explosion" title="Constructing Proof Assistants">Constructing Proof Assistants</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="readable-theorems.xml" addr="readable-theorems" title="Should Kernel Theorems be Readable?">Should Kernel Theorems be Readable?</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="rel-judgements-fol.xml" addr="rel-judgements-fol" title="Judgements and FOL">Judgements and FOL</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="rel-judgements-natural-deduction.xml" addr="rel-judgements-natural-deduction" title="Judgements and Natural Deduction">Judgements and Natural Deduction</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="signature.xml" addr="signature" title="Signatures">Signatures</fr:link></fr:li>
                    <fr:li><fr:strong>Lemma</fr:strong>. <fr:link type="local" href="srs-eager-is-eager.xml" addr="srs-eager-is-eager" title="Eager Evaluation is Eager">Eager Evaluation is Eager</fr:link></fr:li>
                    <fr:li><fr:strong>Proof</fr:strong>. <fr:link type="local" href="srs-eager-prop-proof.xml" addr="srs-eager-prop-proof" title="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:link></fr:li>
                    <fr:li><fr:strong>Theorem</fr:strong>. <fr:link type="local" href="srs-eager-prop.xml" addr="srs-eager-prop" title="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:link></fr:li>
                    <fr:li><fr:strong>Theorem</fr:strong>. <fr:link type="local" href="srs-eager-twice-noop.xml" addr="srs-eager-twice-noop" title="Normalizing Normalize Does Nothing">Normalizing Normalize Does Nothing</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">Eager Evaluation in String Rewrite Systems</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">String Rewrite System</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="tactics.xml" addr="tactics" title="Tactics">Tactics</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="tt-as-algebra.xml" addr="tt-as-algebra" title="Type Theories as Algebraic Theories">Type Theories as Algebraic Theories</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="tt-as-cwf.xml" addr="tt-as-cwf" title="Type Theories as Categories with Families">Type Theories as Categories with Families</fr:link></fr:li>
                    <fr:li><fr:strong>Discussion</fr:strong>. <fr:link type="local" href="type-theory.xml" addr="type-theory" title="Type Theory">Type Theory</fr:link></fr:li>
                    <fr:li><fr:strong>Definition</fr:strong>. <fr:link type="local" href="vernacular.xml" addr="vernacular" title="Vernacular Languages">Vernacular Languages</fr:link></fr:li>
                    <fr:li><fr:strong>Remark</fr:strong>. <fr:link type="local" href="why-formal-elab.xml" addr="why-formal-elab" title="Why Formalize Elaboration?">Why Formalize Elaboration?</fr:link></fr:li>
                  </fr:ul>
                </fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>277</fr:anchor>
            <fr:addr type="user">proof-assistant-explosion</fr:addr>
            <fr:route>proof-assistant-explosion.xml</fr:route>
            <fr:title text="Constructing Proof Assistants">Constructing Proof Assistants</fr:title>
            <fr:taxon>Problem</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>3</fr:month>
              <fr:day>31</fr:day>
            </fr:date>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>246</fr:anchor>
                <fr:addr type="user">programming-language-explosion</fr:addr>
                <fr:route>programming-language-explosion.xml</fr:route>
                <fr:title text="Continued Explosion of Programming Languages">Continued Explosion of Programming Languages</fr:title>
                <fr:taxon>Remark</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>It has been known in the PL community for a long time that the number of programming languages has been rising at an increasing rate. This is because there are an increasingly large number of tools that <fr:em>abstract</fr:em> over various parts of language construction, thereby making the entire process much quicker. This is a good thing! It allows for rapid experimentation and iteration on new ideas.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>A problem the proof assistant community faces is that we do not have the same abstractions for constructing provers that the PL people have. We must implement complex algorithms like higher-order unification and normalization-by-evaluation over and over again with slight variations. In recent times there is an ever-growing need for constructing provers to be easier due to the number of new type theories emerging, but we currently do not have the tools to develop provers for these theories at a fast-enough rate.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>278</fr:anchor>
            <fr:addr type="user">programming-language-explosion</fr:addr>
            <fr:route>programming-language-explosion.xml</fr:route>
            <fr:title text="Continued Explosion of Programming Languages">Continued Explosion of Programming Languages</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>3</fr:month>
              <fr:day>31</fr:day>
            </fr:date>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>It has been known in the PL community for a long time that the number of programming languages has been rising at an increasing rate. This is because there are an increasingly large number of tools that <fr:em>abstract</fr:em> over various parts of language construction, thereby making the entire process much quicker. This is a good thing! It allows for rapid experimentation and iteration on new ideas.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>279</fr:anchor>
            <fr:addr type="user">macro-elab-definition</fr:addr>
            <fr:route>macro-elab-definition.xml</fr:route>
            <fr:title text="A Macro-Based Explanation of Elaboration">A Macro-Based Explanation of Elaboration</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A preliminary definition of <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">elaboration</fr:link> we may use essentially just captures the initial <fr:link type="local" href="elaboration-intuition.xml" addr="elaboration-intuition" title="Elaboration, Intuitively">intuition for elaboration</fr:link> in a more systematic way. An elaborator is quite literally just a set of syntactic macro rules which may both spawn and solve <fr:em>metavariables</fr:em>. Furthermore the macros have access to the <fr:em>goal type</fr:em>, which captures the type-directed nature of elaboration.</fr:p>
            <fr:p>The macro rules are permitted to executed arbitrary code in some metalanguage, which allows for typeclass resolution, unification, and etc to be implemented. This is essentially the direction that Lean 4 seems to have gone -- the user at any point may insert arbitrary definitions of new syntax and transformations on that syntax, and elaboration recursively expands macros until it cannot anymore.</fr:p>
            <fr:p>This definition is very unsatisfying mathematically though! This is because all it does is capture the initial intuition. Tt provides no new information nor insights into what elaboration <fr:em>should</fr:em> be, nor what it is in relation to the rest of mathematics. Thus this definition is unsuitable for a formalization of elaboration.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>280</fr:anchor>
            <fr:addr type="user">admissible-rule</fr:addr>
            <fr:route>admissible-rule.xml</fr:route>
            <fr:title text="Admissible Rules">Admissible Rules</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">theory</fr:link> <fr:tex display="inline"><![CDATA[\mathbb {T}]]></fr:tex>, an axiom is admissible if adding it to <fr:tex display="inline"><![CDATA[\mathbb {T}]]></fr:tex> doesn't change <fr:tex display="inline"><![CDATA[\mathbb {T}]]></fr:tex>'s set of <fr:em>theorems</fr:em>, i.e the set of true <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">judgements</fr:link>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>281</fr:anchor>
            <fr:addr type="user">algebra</fr:addr>
            <fr:route>algebra.xml</fr:route>
            <fr:title text="Algebra">Algebra</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>TODO</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>282</fr:anchor>
            <fr:addr type="user">categories-with-families</fr:addr>
            <fr:route>categories-with-families.xml</fr:route>
            <fr:title text="Categories with Families">Categories with Families</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>TODO</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>283</fr:anchor>
            <fr:addr type="user">srs-eager</fr:addr>
            <fr:route>srs-eager.xml</fr:route>
            <fr:title text="Eager Evaluation in String Rewrite Systems">Eager Evaluation in String Rewrite Systems</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>The eager evaluation strategy <fr:tex display="inline"><![CDATA[\textbf {norm}(s)]]></fr:tex> on a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link> <fr:tex display="inline"><![CDATA[\rightsquigarrow ]]></fr:tex> is merely to take the fixpoint of the function that performs the leftmost reduction on <fr:tex display="inline"><![CDATA[s]]></fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>284</fr:anchor>
            <fr:addr type="user">srs-eager-is-eager</fr:addr>
            <fr:route>srs-eager-is-eager.xml</fr:route>
            <fr:title text="Eager Evaluation is Eager">Eager Evaluation is Eager</fr:title>
            <fr:taxon>Lemma</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
            <fr:tex display="block"><![CDATA[   \frac {     s \rightsquigarrow  t   }{     \textbf {norm}(s \cdot  r) = \textbf {norm}(t \cdot  r)   } ]]></fr:tex>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>285</fr:anchor>
            <fr:addr type="user">elaboration</fr:addr>
            <fr:route>elaboration.xml</fr:route>
            <fr:title text="Elaboration">Elaboration</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>254</fr:anchor>
                <fr:addr type="user">elaboration-intuition</fr:addr>
                <fr:route>elaboration-intuition.xml</fr:route>
                <fr:title text="Elaboration, Intuitively">Elaboration, Intuitively</fr:title>
                <fr:taxon>Discussion</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Elaboration is a concept that pops up in every proof assistant, but what is it? Intuitively, elaboration seems to have two main qualities:
  <fr:ol><fr:li>It functions somewhat like <fr:link type="local" href="macro-expansion.xml" addr="macro-expansion" title="Macro Expansion">macro expansion</fr:link>. Given some term in the <fr:link type="local" href="vernacular.xml" addr="vernacular" title="Vernacular Languages">vernacular</fr:link>, an elaborator will lower it down to a term in the <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">kernel language</fr:link>.</fr:li>
    <fr:li>It involves reconstruction of information left implicit by the user.</fr:li></fr:ol></fr:p>
                <fr:p>The key thing that makes this like macro expansion is that the kernel term that the vernacular term expanded to may be <fr:em>observed</fr:em> by the user. If you write a term in a type signature and look at the goal the system gives you for the definition, you're going to see the kernel term. Kernel terms are not necessarily human-readable, so pretty-printing will likely do a lot of work to massage the goal into a nice form, but this is purely syntactic tricks, the term is ultimately still in the kernel language.</fr:p>
                <fr:p>Expanding a bit on the second quality: For instance, the elaborator may perform type inference to fill a metavariable, or perform typeclass resolution to fill a class obligation, or use the type of an expression to determine what notation scope to interpret it in. All of these things are information that the elaborator implicitly reconstructs for the user.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>255</fr:anchor>
                <fr:addr type="user">macro-elab-definition</fr:addr>
                <fr:route>macro-elab-definition.xml</fr:route>
                <fr:title text="A Macro-Based Explanation of Elaboration">A Macro-Based Explanation of Elaboration</fr:title>
                <fr:taxon>Discussion</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>A preliminary definition of <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">elaboration</fr:link> we may use essentially just captures the initial <fr:link type="local" href="elaboration-intuition.xml" addr="elaboration-intuition" title="Elaboration, Intuitively">intuition for elaboration</fr:link> in a more systematic way. An elaborator is quite literally just a set of syntactic macro rules which may both spawn and solve <fr:em>metavariables</fr:em>. Furthermore the macros have access to the <fr:em>goal type</fr:em>, which captures the type-directed nature of elaboration.</fr:p>
                <fr:p>The macro rules are permitted to executed arbitrary code in some metalanguage, which allows for typeclass resolution, unification, and etc to be implemented. This is essentially the direction that Lean 4 seems to have gone -- the user at any point may insert arbitrary definitions of new syntax and transformations on that syntax, and elaboration recursively expands macros until it cannot anymore.</fr:p>
                <fr:p>This definition is very unsatisfying mathematically though! This is because all it does is capture the initial intuition. Tt provides no new information nor insights into what elaboration <fr:em>should</fr:em> be, nor what it is in relation to the rest of mathematics. Thus this definition is unsuitable for a formalization of elaboration.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>256</fr:anchor>
                <fr:addr type="user">elaboration-formal</fr:addr>
                <fr:route>elaboration-formal.xml</fr:route>
                <fr:title text="Elaboration, Formally">Elaboration, Formally</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>257</fr:anchor>
                    <fr:addr type="user">why-formal-elab</fr:addr>
                    <fr:route>why-formal-elab.xml</fr:route>
                    <fr:title text="Why Formalize Elaboration?">Why Formalize Elaboration?</fr:title>
                    <fr:taxon>Remark</fr:taxon>
                    <fr:authors />
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Formally defining elaboration is important for two broad reasons.
  <fr:ol><fr:li>It forces us to determine what elaboration <fr:em>should</fr:em> be. What do the "best" examples of elaborators look like, and how do we determine what a "bad" elaborator is?</fr:li>
    <fr:li>It paves the way for developing abstractions in the space of elaborators. This allows for reusable software components to be developed, which is essential to <fr:link type="local" href="proof-assistant-explosion.xml" addr="proof-assistant-explosion" title="Constructing Proof Assistants">making construction of proof assistants easier</fr:link>.</fr:li></fr:ol></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter />
                </fr:tree>
                <fr:p>TODO</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>286</fr:anchor>
            <fr:addr type="user">elaboration-formal</fr:addr>
            <fr:route>elaboration-formal.xml</fr:route>
            <fr:title text="Elaboration, Formally">Elaboration, Formally</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>257</fr:anchor>
                <fr:addr type="user">why-formal-elab</fr:addr>
                <fr:route>why-formal-elab.xml</fr:route>
                <fr:title text="Why Formalize Elaboration?">Why Formalize Elaboration?</fr:title>
                <fr:taxon>Remark</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Formally defining elaboration is important for two broad reasons.
  <fr:ol><fr:li>It forces us to determine what elaboration <fr:em>should</fr:em> be. What do the "best" examples of elaborators look like, and how do we determine what a "bad" elaborator is?</fr:li>
    <fr:li>It paves the way for developing abstractions in the space of elaborators. This allows for reusable software components to be developed, which is essential to <fr:link type="local" href="proof-assistant-explosion.xml" addr="proof-assistant-explosion" title="Constructing Proof Assistants">making construction of proof assistants easier</fr:link>.</fr:li></fr:ol></fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>TODO</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>287</fr:anchor>
            <fr:addr type="user">elaboration-intuition</fr:addr>
            <fr:route>elaboration-intuition.xml</fr:route>
            <fr:title text="Elaboration, Intuitively">Elaboration, Intuitively</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Elaboration is a concept that pops up in every proof assistant, but what is it? Intuitively, elaboration seems to have two main qualities:
  <fr:ol><fr:li>It functions somewhat like <fr:link type="local" href="macro-expansion.xml" addr="macro-expansion" title="Macro Expansion">macro expansion</fr:link>. Given some term in the <fr:link type="local" href="vernacular.xml" addr="vernacular" title="Vernacular Languages">vernacular</fr:link>, an elaborator will lower it down to a term in the <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">kernel language</fr:link>.</fr:li>
    <fr:li>It involves reconstruction of information left implicit by the user.</fr:li></fr:ol></fr:p>
            <fr:p>The key thing that makes this like macro expansion is that the kernel term that the vernacular term expanded to may be <fr:em>observed</fr:em> by the user. If you write a term in a type signature and look at the goal the system gives you for the definition, you're going to see the kernel term. Kernel terms are not necessarily human-readable, so pretty-printing will likely do a lot of work to massage the goal into a nice form, but this is purely syntactic tricks, the term is ultimately still in the kernel language.</fr:p>
            <fr:p>Expanding a bit on the second quality: For instance, the elaborator may perform type inference to fill a metavariable, or perform typeclass resolution to fill a class obligation, or use the type of an expression to determine what notation scope to interpret it in. All of these things are information that the elaborator implicitly reconstructs for the user.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>288</fr:anchor>
            <fr:addr type="user">judgement</fr:addr>
            <fr:route>judgement.xml</fr:route>
            <fr:title text="Judgements">Judgements</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>The <fr:em>judgements</fr:em> over a <fr:link type="local" href="signature.xml" addr="signature" title="Signatures">signature</fr:link> <fr:tex display="inline"><![CDATA[E]]></fr:tex> are defined as follows.
  <fr:tex display="block"><![CDATA[     \mathcal {J} :=       \mathcal {R}(\overline {e}) \,\, | \,\,       \{x\} \, \mathcal {J} \,\, | \,\,       \mathcal {J} \vdash  \mathcal {J}   ]]></fr:tex>
  The proof rules for judgements are then straightfoward.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[\mathcal {R}(\overline {e})]]></fr:tex>: Supplied by the background <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">theory</fr:link></fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\{x\} \, \mathcal {J}]]></fr:tex>: Generalization and specialization</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\mathcal {H} \vdash  \mathcal {J}]]></fr:tex>: Abstraction and application</fr:li></fr:ul></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>289</fr:anchor>
            <fr:addr type="user">judgements-disc</fr:addr>
            <fr:route>judgements-disc.xml</fr:route>
            <fr:title text="Judgements">Judgements</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>290</fr:anchor>
                <fr:addr type="user">judgement</fr:addr>
                <fr:route>judgement.xml</fr:route>
                <fr:title text="Judgements">Judgements</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>The <fr:em>judgements</fr:em> over a <fr:link type="local" href="signature.xml" addr="signature" title="Signatures">signature</fr:link> <fr:tex display="inline"><![CDATA[E]]></fr:tex> are defined as follows.
  <fr:tex display="block"><![CDATA[     \mathcal {J} :=       \mathcal {R}(\overline {e}) \,\, | \,\,       \{x\} \, \mathcal {J} \,\, | \,\,       \mathcal {J} \vdash  \mathcal {J}   ]]></fr:tex>
  The proof rules for judgements are then straightfoward.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[\mathcal {R}(\overline {e})]]></fr:tex>: Supplied by the background <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">theory</fr:link></fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\{x\} \, \mathcal {J}]]></fr:tex>: Generalization and specialization</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\mathcal {H} \vdash  \mathcal {J}]]></fr:tex>: Abstraction and application</fr:li></fr:ul></fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>291</fr:anchor>
                <fr:addr type="user">rel-judgements-fol</fr:addr>
                <fr:route>rel-judgements-fol.xml</fr:route>
                <fr:title text="Judgements and FOL">Judgements and FOL</fr:title>
                <fr:taxon>Remark</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>One may notice that the syntax of <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">judgements</fr:link> is merely a fragment of FOL. The transformation is syntactic.
  <fr:tex display="block"><![CDATA[     \mathcal {J} :=       \mathcal {R}(\overline {e}) \,\, | \,\,       \forall  x. \, \mathcal {J} \,\, | \,\,       \mathcal {J} \Rightarrow  \mathcal {J}   ]]></fr:tex></fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>292</fr:anchor>
                <fr:addr type="user">rel-judgements-natural-deduction</fr:addr>
                <fr:route>rel-judgements-natural-deduction.xml</fr:route>
                <fr:title text="Judgements and Natural Deduction">Judgements and Natural Deduction</fr:title>
                <fr:taxon>Remark</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Switching between traditional natural deduction syntax and judgement syntax is a simple syntactic transformation. Do as follows, where the generalized judgement on the right quantifies over all the metavariables on the left.
  <fr:tex display="block"><![CDATA[     \frac {       \mathcal {H}_0 \,\,       \dots  \,\,       \mathcal {H}_n     }{       \mathcal {J}     }     \quad      \longrightarrow      \quad      \{\,\dots \} \,\, \mathcal {H}_0 \dots  \mathcal {H}_n \vdash  \mathcal {J}   ]]></fr:tex></fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>293</fr:anchor>
            <fr:addr type="user">rel-judgements-fol</fr:addr>
            <fr:route>rel-judgements-fol.xml</fr:route>
            <fr:title text="Judgements and FOL">Judgements and FOL</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>One may notice that the syntax of <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">judgements</fr:link> is merely a fragment of FOL. The transformation is syntactic.
  <fr:tex display="block"><![CDATA[     \mathcal {J} :=       \mathcal {R}(\overline {e}) \,\, | \,\,       \forall  x. \, \mathcal {J} \,\, | \,\,       \mathcal {J} \Rightarrow  \mathcal {J}   ]]></fr:tex></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>294</fr:anchor>
            <fr:addr type="user">rel-judgements-natural-deduction</fr:addr>
            <fr:route>rel-judgements-natural-deduction.xml</fr:route>
            <fr:title text="Judgements and Natural Deduction">Judgements and Natural Deduction</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Switching between traditional natural deduction syntax and judgement syntax is a simple syntactic transformation. Do as follows, where the generalized judgement on the right quantifies over all the metavariables on the left.
  <fr:tex display="block"><![CDATA[     \frac {       \mathcal {H}_0 \,\,       \dots  \,\,       \mathcal {H}_n     }{       \mathcal {J}     }     \quad      \longrightarrow      \quad      \{\,\dots \} \,\, \mathcal {H}_0 \dots  \mathcal {H}_n \vdash  \mathcal {J}   ]]></fr:tex></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>295</fr:anchor>
            <fr:addr type="user">kernel</fr:addr>
            <fr:route>kernel.xml</fr:route>
            <fr:title text="Kernel Languages">Kernel Languages</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A kernel is a logic designed to be simple, expressive, and easily machine-readable. The readability for humans is explicitly an <fr:em>anti</fr:em>-concern, kernel logics are meant to be the central source of truth for a proof assistant, and thus cannot be bound up in imprecise human reasoning.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>296</fr:anchor>
            <fr:addr type="user">srs-eager-prop</fr:addr>
            <fr:route>srs-eager-prop.xml</fr:route>
            <fr:title text="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
            <fr:tex display="block"><![CDATA[   \frac {     s \rightsquigarrow  t   }{     \textbf {norm}(l \cdot  s \cdot  r) = \textbf {norm}(l \cdot  t \cdot  r)   } ]]></fr:tex>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>297</fr:anchor>
            <fr:addr type="user">srs-eager-prop-proof</fr:addr>
            <fr:route>srs-eager-prop-proof.xml</fr:route>
            <fr:title text="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:title>
            <fr:taxon>Proof</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>298</fr:anchor>
                <fr:addr type="user">srs-eager-prop</fr:addr>
                <fr:route>srs-eager-prop.xml</fr:route>
                <fr:title text="Local Rewriting Preserves Normal Forms">Local Rewriting Preserves Normal Forms</fr:title>
                <fr:taxon>Theorem</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
                <fr:tex display="block"><![CDATA[   \frac {     s \rightsquigarrow  t   }{     \textbf {norm}(l \cdot  s \cdot  r) = \textbf {norm}(l \cdot  t \cdot  r)   } ]]></fr:tex>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>We want to prove that, given a string rewrite system, <fr:link type="local" href="srs-eager-prop.xml" addr="srs-eager-prop" title="Local Rewriting Preserves Normal Forms">local rewrites preserve normal forms</fr:link>. First, we notice the following lemmas</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>299</fr:anchor>
                <fr:addr type="user">srs-eager-twice-noop</fr:addr>
                <fr:route>srs-eager-twice-noop.xml</fr:route>
                <fr:title text="Normalizing Normalize Does Nothing">Normalizing Normalize Does Nothing</fr:title>
                <fr:taxon>Theorem</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
                <fr:tex display="block"><![CDATA[   \frac {    }{     \textbf {norm}(x \cdot  y \cdot  z) = \textbf {norm}(x \cdot  \textbf {norm}(y \cdot  z))   } ]]></fr:tex>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>300</fr:anchor>
                <fr:addr type="user">srs-eager-is-eager</fr:addr>
                <fr:route>srs-eager-is-eager.xml</fr:route>
                <fr:title text="Eager Evaluation is Eager">Eager Evaluation is Eager</fr:title>
                <fr:taxon>Lemma</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
                <fr:tex display="block"><![CDATA[   \frac {     s \rightsquigarrow  t   }{     \textbf {norm}(s \cdot  r) = \textbf {norm}(t \cdot  r)   } ]]></fr:tex>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>The first lemma is fairly obvious. The second lemma expresses that if there is a redex at the front of a string, the eager evaluation strategy will reduce it first. Now we do this: We first use <fr:link type="local" href="srs-eager-twice-noop.xml" addr="srs-eager-twice-noop" title="Normalizing Normalize Does Nothing">the first lemma</fr:link> to transform the goal into the following.

  <fr:tex display="block"><![CDATA[     \frac {       s \rightsquigarrow  t     }{       \textbf {norm}(l \cdot  s \cdot  r) = \textbf {norm}(l \cdot  \textbf {norm}(t \cdot  r))     }   ]]></fr:tex>

  From here, we use <fr:link type="local" href="srs-eager-is-eager.xml" addr="srs-eager-is-eager" title="Eager Evaluation is Eager">the second lemma</fr:link> to transform it again.

  <fr:tex display="block"><![CDATA[     \frac {      }{       \textbf {norm}(l \cdot  s \cdot  r) = \textbf {norm}(l \cdot  \textbf {norm}(s \cdot  r))     }   ]]></fr:tex>

  Finally, we again use the first lemma, and this final goal is discharged by reflexivity.
  
  <fr:tex display="block"><![CDATA[     \frac {      }{       \textbf {norm}(l \cdot  s \cdot  r) = \textbf {norm}(l \cdot  s \cdot  r)     }   ]]></fr:tex>

  QED.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>301</fr:anchor>
            <fr:addr type="user">macro-expansion</fr:addr>
            <fr:route>macro-expansion.xml</fr:route>
            <fr:title text="Macro Expansion">Macro Expansion</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A macro-expansion is a syntactic transformation. It is a transformation <fr:em>on</fr:em> syntax that appears in the metalanguage. Thus, after macro expansion only terms in the object language may be observed by the user.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>302</fr:anchor>
            <fr:addr type="user">mltt</fr:addr>
            <fr:route>mltt.xml</fr:route>
            <fr:title text="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Martin-Löf Type Theory (MLTT) is a family of <fr:link type="local" href="type-theory.xml" addr="type-theory" title="Type Theory">type theories</fr:link>, and the original form can be regarded as the first "modern" type theory. MLTTs are presented as <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">formal systems</fr:link> over the following four judgements.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li></fr:ul></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>303</fr:anchor>
            <fr:addr type="user">mltt-disc</fr:addr>
            <fr:route>mltt-disc.xml</fr:route>
            <fr:title text="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>269</fr:anchor>
                <fr:addr type="user">mltt</fr:addr>
                <fr:route>mltt.xml</fr:route>
                <fr:title text="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Martin-Löf Type Theory (MLTT) is a family of <fr:link type="local" href="type-theory.xml" addr="type-theory" title="Type Theory">type theories</fr:link>, and the original form can be regarded as the first "modern" type theory. MLTTs are presented as <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">formal systems</fr:link> over the following four judgements.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li></fr:ul></fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>Combined with <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">hypothetical and generalized judgements</fr:link>, the rules of MLTT may then be presented. For instance, the rules for function types look like the following.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>270</fr:anchor>
                <fr:addr type="user">mltt-pi-rules</fr:addr>
                <fr:route>mltt-pi-rules.xml</fr:route>
                <fr:title text="Rules for Pi Types in MLTT">Rules for Pi Types in MLTT</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>
                  <fr:ul><fr:li>Formation, introduction, elimination.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  B \, \text {type}         }{           \Pi _{x : A} \, B \, \text {type}         }         \quad          \frac {           \{x\} \, x : A \vdash  e : B         }{           \lambda  x. \, e : \Pi _{x : A} \, B         }         \quad          \frac {           f : \Pi _{x : A} \, B \quad            a : A         }{           f \, a : B[x \mapsto  a]         }       ]]></fr:tex></fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\beta ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex> equations.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  e : B \quad            a : A         }{           (\lambda  x. \, e) \, a = e[x \mapsto  a] : B[x \mapsto  a]         }         \quad          \frac {           f : \Pi _{x : A} \, B         }{           f = \lambda  x. \, f \, x : \Pi _{x : A} \, B         }       ]]></fr:tex></fr:li></fr:ul>
                </fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>271</fr:anchor>
                <fr:addr type="user">mltt-pres-trad</fr:addr>
                <fr:route>mltt-pres-trad.xml</fr:route>
                <fr:title text="Traditional Presentation of MLTT">Traditional Presentation of MLTT</fr:title>
                <fr:taxon>Remark</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>In contrast to <fr:link type="local" href="mltt.xml" addr="mltt" title="Martin-Löf Type Theory">my presentation of MLTT's judgements</fr:link>, the traditional presentation of MLTT usually combines the hypothetical judgement with each of the typing/equation <fr:link type="external" href="judgements">judgements</fr:link>, i.e the traditional presentation looks like the following.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li></fr:ul>
  Where each <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex> are <fr:em>multisets</fr:em> containing typings <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. Finally, the <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">generalized judgement</fr:link> is left implicit. This more specialized presentation is valid because in traditional MLTT, the hypothetical judgements <fr:em>only</fr:em> abstract over typing judgements <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. I use the contextless presentation because it is more general and also a bit easier to read.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>304</fr:anchor>
            <fr:addr type="user">srs-eager-twice-noop</fr:addr>
            <fr:route>srs-eager-twice-noop.xml</fr:route>
            <fr:title text="Normalizing Normalize Does Nothing">Normalizing Normalize Does Nothing</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a <fr:link type="local" href="string-rewrite-system.xml" addr="string-rewrite-system" title="String Rewrite System">string rewrite system</fr:link>, the following holds of <fr:link type="local" href="srs-eager.xml" addr="srs-eager" title="Eager Evaluation in String Rewrite Systems">eager evaluation</fr:link>.</fr:p>
            <fr:tex display="block"><![CDATA[   \frac {    }{     \textbf {norm}(x \cdot  y \cdot  z) = \textbf {norm}(x \cdot  \textbf {norm}(y \cdot  z))   } ]]></fr:tex>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>305</fr:anchor>
            <fr:addr type="user">mltt-pi-rules</fr:addr>
            <fr:route>mltt-pi-rules.xml</fr:route>
            <fr:title text="Rules for Pi Types in MLTT">Rules for Pi Types in MLTT</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>
              <fr:ul><fr:li>Formation, introduction, elimination.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  B \, \text {type}         }{           \Pi _{x : A} \, B \, \text {type}         }         \quad          \frac {           \{x\} \, x : A \vdash  e : B         }{           \lambda  x. \, e : \Pi _{x : A} \, B         }         \quad          \frac {           f : \Pi _{x : A} \, B \quad            a : A         }{           f \, a : B[x \mapsto  a]         }       ]]></fr:tex></fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\beta ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex> equations.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  e : B \quad            a : A         }{           (\lambda  x. \, e) \, a = e[x \mapsto  a] : B[x \mapsto  a]         }         \quad          \frac {           f : \Pi _{x : A} \, B         }{           f = \lambda  x. \, f \, x : \Pi _{x : A} \, B         }       ]]></fr:tex></fr:li></fr:ul>
            </fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>306</fr:anchor>
            <fr:addr type="user">readable-theorems</fr:addr>
            <fr:route>readable-theorems.xml</fr:route>
            <fr:title text="Should Kernel Theorems be Readable?">Should Kernel Theorems be Readable?</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A key quality of <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">kernel</fr:link> logics is that they are explicitly geared toward being <fr:em>machine</fr:em>-readable rather than human readable. But does this extend only to the proofs, only to the propositions, or to both?</fr:p>
            <fr:p>What I believe is that while the proofs need not be human-readable, the propositions <fr:em>should</fr:em>. This is because ultimately the machine should follow the <fr:link type="external" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least surprise</fr:link>. What this means simply is that the machine should never try to guess the user's intent. One of the worst errors you can make as a mathematician is proving the wrong theorem -- even worse if the machine <fr:em>misinterpreted</fr:em> the theorem you meant to prove!</fr:p>
            <fr:p>Machines can be quite clever, but cleverness is not cleverness at all if the machine is not obeying the user! What this tells us is that the machine should never employ clever strategies when <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">elaborating</fr:link> the propositions the user supplies, but may employ anything it wishes when elaborating the user's proofs.</fr:p>
            <fr:p>In practice anyway, propositions employ far less complicated constructs than proofs, meaning that we don't lose much by requiring this principle to be followed.</fr:p>
            <fr:p>This also fuels some of my gripes about dependent types. Allowing arbitrary programs to execute in the propositions destroys the nice separation between the machine-readable world and the human-readable world. In dependently typed proof assistants, the machine can surprise you!</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>307</fr:anchor>
            <fr:addr type="user">signature</fr:addr>
            <fr:route>signature.xml</fr:route>
            <fr:title text="Signatures">Signatures</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A signature (also known as a <fr:em>language</fr:em>) is a tuple <fr:tex display="inline"><![CDATA[(E, \alpha )]]></fr:tex>, where <fr:tex display="inline"><![CDATA[E]]></fr:tex> is a set of symbols and <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> assigns each symbols an <fr:em>arity</fr:em>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>308</fr:anchor>
            <fr:addr type="user">string-rewrite-system</fr:addr>
            <fr:route>string-rewrite-system.xml</fr:route>
            <fr:title text="String Rewrite System">String Rewrite System</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A string rewrite system over a set <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is a relation <fr:tex display="inline"><![CDATA[\rightsquigarrow  \, \in  \Sigma ^\star  \to  \Sigma ^\star ]]></fr:tex>. The path relation is generated by taking the reflexive-transitive closure over the <fr:em>lift</fr:em> of this relation, which turns the relation from one that handles local rewrites to one that handles global rewrites.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>309</fr:anchor>
            <fr:addr type="user">tactics</fr:addr>
            <fr:route>tactics.xml</fr:route>
            <fr:title text="Tactics">Tactics</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Tactics are a common <fr:link type="local" href="vernacular.xml" addr="vernacular" title="Vernacular Languages">vernacular language</fr:link> feature, prominently used in proof assistants like Rocq, Lean, and HOL. There doesn't seem to be a formalization out there, but tactic languages share some common features.
  <fr:ul><fr:li>Tactics are semi-arbitrary code in a metalanguage that uses an API to construct <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">kernel</fr:link> terms. The terms may be typechecked post-hoc a la Lean or Rocq, or the API ensures terms are correct-by-construction.</fr:li>
    <fr:li>Tactics are encouraged to be used only in <fr:em>proof-irrelevant</fr:em> settings. This is an informal contract between the tactic user and tactic implementor: The user promises not to depend on the proof terms constructed by tactics, and the implementor interprets this as a freedom that makes constructing the tactic easier.</fr:li>
    <fr:li>They implement forward chaining in that each tactic essentially implements an implication -- each application of a tactic solves a goal by spawning subgoals that entail it. This enables interactive proofs, with each tactic being an individual "unit" of the proof that the user may step through. At every step the user may pause, evaluate, and consider which tactic should next be applied.</fr:li></fr:ul></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>310</fr:anchor>
            <fr:addr type="user">first-order-theory</fr:addr>
            <fr:route>first-order-theory.xml</fr:route>
            <fr:title text="Theories">Theories</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A theory over a <fr:link type="local" href="signature.xml" addr="signature" title="Signatures">signature</fr:link> <fr:tex display="inline"><![CDATA[E]]></fr:tex> is merely a set of <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">judgements</fr:link> over <fr:tex display="inline"><![CDATA[E]]></fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>311</fr:anchor>
            <fr:addr type="user">mltt-pres-trad</fr:addr>
            <fr:route>mltt-pres-trad.xml</fr:route>
            <fr:title text="Traditional Presentation of MLTT">Traditional Presentation of MLTT</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>In contrast to <fr:link type="local" href="mltt.xml" addr="mltt" title="Martin-Löf Type Theory">my presentation of MLTT's judgements</fr:link>, the traditional presentation of MLTT usually combines the hypothetical judgement with each of the typing/equation <fr:link type="external" href="judgements">judgements</fr:link>, i.e the traditional presentation looks like the following.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li></fr:ul>
  Where each <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex> are <fr:em>multisets</fr:em> containing typings <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. Finally, the <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">generalized judgement</fr:link> is left implicit. This more specialized presentation is valid because in traditional MLTT, the hypothetical judgements <fr:em>only</fr:em> abstract over typing judgements <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. I use the contextless presentation because it is more general and also a bit easier to read.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>312</fr:anchor>
            <fr:addr type="user">tt-as-algebra</fr:addr>
            <fr:route>tt-as-algebra.xml</fr:route>
            <fr:title text="Type Theories as Algebraic Theories">Type Theories as Algebraic Theories</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>TODO</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>313</fr:anchor>
            <fr:addr type="user">tt-as-cwf</fr:addr>
            <fr:route>tt-as-cwf.xml</fr:route>
            <fr:title text="Type Theories as Categories with Families">Type Theories as Categories with Families</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>TODO</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>314</fr:anchor>
            <fr:addr type="user">type-theory</fr:addr>
            <fr:route>type-theory.xml</fr:route>
            <fr:title text="Type Theory">Type Theory</fr:title>
            <fr:taxon>Discussion</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Type theory is a style of formal system that emphasizes syntax.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>268</fr:anchor>
                <fr:addr type="user">mltt-disc</fr:addr>
                <fr:route>mltt-disc.xml</fr:route>
                <fr:title text="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:title>
                <fr:taxon>Discussion</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>269</fr:anchor>
                    <fr:addr type="user">mltt</fr:addr>
                    <fr:route>mltt.xml</fr:route>
                    <fr:title text="Martin-Löf Type Theory">Martin-Löf Type Theory</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors />
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Martin-Löf Type Theory (MLTT) is a family of <fr:link type="local" href="type-theory.xml" addr="type-theory" title="Type Theory">type theories</fr:link>, and the original form can be regarded as the first "modern" type theory. MLTTs are presented as <fr:link type="local" href="first-order-theory.xml" addr="first-order-theory" title="Theories">formal systems</fr:link> over the following four judgements.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter />
                </fr:tree>
                <fr:p>Combined with <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">hypothetical and generalized judgements</fr:link>, the rules of MLTT may then be presented. For instance, the rules for function types look like the following.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>270</fr:anchor>
                    <fr:addr type="user">mltt-pi-rules</fr:addr>
                    <fr:route>mltt-pi-rules.xml</fr:route>
                    <fr:title text="Rules for Pi Types in MLTT">Rules for Pi Types in MLTT</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors />
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>
                      <fr:ul><fr:li>Formation, introduction, elimination.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  B \, \text {type}         }{           \Pi _{x : A} \, B \, \text {type}         }         \quad          \frac {           \{x\} \, x : A \vdash  e : B         }{           \lambda  x. \, e : \Pi _{x : A} \, B         }         \quad          \frac {           f : \Pi _{x : A} \, B \quad            a : A         }{           f \, a : B[x \mapsto  a]         }       ]]></fr:tex></fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\beta ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex> equations.
      <fr:tex display="block"><![CDATA[         \frac {           A \, \text {type} \quad            \{x\} \, x : A \vdash  e : B \quad            a : A         }{           (\lambda  x. \, e) \, a = e[x \mapsto  a] : B[x \mapsto  a]         }         \quad          \frac {           f : \Pi _{x : A} \, B         }{           f = \lambda  x. \, f \, x : \Pi _{x : A} \, B         }       ]]></fr:tex></fr:li></fr:ul>
                    </fr:p>
                  </fr:mainmatter>
                  <fr:backmatter />
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>271</fr:anchor>
                    <fr:addr type="user">mltt-pres-trad</fr:addr>
                    <fr:route>mltt-pres-trad.xml</fr:route>
                    <fr:title text="Traditional Presentation of MLTT">Traditional Presentation of MLTT</fr:title>
                    <fr:taxon>Remark</fr:taxon>
                    <fr:authors />
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In contrast to <fr:link type="local" href="mltt.xml" addr="mltt" title="Martin-Löf Type Theory">my presentation of MLTT's judgements</fr:link>, the traditional presentation of MLTT usually combines the hypothetical judgement with each of the typing/equation <fr:link type="external" href="judgements">judgements</fr:link>, i.e the traditional presentation looks like the following.
  <fr:ul><fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a well-formed type in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  A = B \, \text {type}]]></fr:tex>. <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are equal types in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> has type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex display="inline"><![CDATA[\Gamma  \vdash  s = t : A]]></fr:tex>. <fr:tex display="inline"><![CDATA[s]]></fr:tex> and <fr:tex display="inline"><![CDATA[t]]></fr:tex> are equal terms of type <fr:tex display="inline"><![CDATA[A]]></fr:tex> in context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li></fr:ul>
  Where each <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex> are <fr:em>multisets</fr:em> containing typings <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. Finally, the <fr:link type="local" href="judgement.xml" addr="judgement" title="Judgements">generalized judgement</fr:link> is left implicit. This more specialized presentation is valid because in traditional MLTT, the hypothetical judgements <fr:em>only</fr:em> abstract over typing judgements <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>. I use the contextless presentation because it is more general and also a bit easier to read.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter />
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>The metatheory of type theory is still being developed, but generally people have converged on giving type theories semantics in <fr:link type="local" href="categories-with-families.xml" addr="categories-with-families" title="Categories with Families">categories with families</fr:link> and <fr:link type="local" href="algebra.xml" addr="algebra" title="Algebra">algebraic theories</fr:link>.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>272</fr:anchor>
                <fr:addr type="user">tt-as-cwf</fr:addr>
                <fr:route>tt-as-cwf.xml</fr:route>
                <fr:title text="Type Theories as Categories with Families">Type Theories as Categories with Families</fr:title>
                <fr:taxon>Discussion</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>TODO</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>273</fr:anchor>
                <fr:addr type="user">tt-as-algebra</fr:addr>
                <fr:route>tt-as-algebra.xml</fr:route>
                <fr:title text="Type Theories as Algebraic Theories">Type Theories as Algebraic Theories</fr:title>
                <fr:taxon>Discussion</fr:taxon>
                <fr:authors />
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>TODO</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>315</fr:anchor>
            <fr:addr type="user">vernacular</fr:addr>
            <fr:route>vernacular.xml</fr:route>
            <fr:title text="Vernacular Languages">Vernacular Languages</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>The concept of a vernacular is central to proof assistants, but it is not usually defined. The vernacular completes the separation of concerns that the <fr:link type="local" href="kernel.xml" addr="kernel" title="Kernel Languages">kernel</fr:link> begins -- it is a language with human-comprehensible propositions and proofs. Vernacular languages take many forms, for instance an <fr:link type="local" href="elaboration.xml" addr="elaboration" title="Elaboration">elaborator</fr:link> may lower vernacular syntax down to kernel syntax, or kernel syntax may be constructed by <fr:link type="local" href="tactics.xml" addr="tactics" title="Tactics">tactics</fr:link>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>316</fr:anchor>
            <fr:addr type="user">why-formal-elab</fr:addr>
            <fr:route>why-formal-elab.xml</fr:route>
            <fr:title text="Why Formalize Elaboration?">Why Formalize Elaboration?</fr:title>
            <fr:taxon>Remark</fr:taxon>
            <fr:authors />
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Formally defining elaboration is important for two broad reasons.
  <fr:ol><fr:li>It forces us to determine what elaboration <fr:em>should</fr:em> be. What do the "best" examples of elaborators look like, and how do we determine what a "bad" elaborator is?</fr:li>
    <fr:li>It paves the way for developing abstractions in the space of elaborators. This allows for reusable software components to be developed, which is essential to <fr:link type="local" href="proof-assistant-explosion.xml" addr="proof-assistant-explosion" title="Constructing Proof Assistants">making construction of proof assistants easier</fr:link>.</fr:li></fr:ol></fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
